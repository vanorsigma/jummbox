import { Dictionary, DictionaryArray, FilterType, SustainType, EnvelopeType, InstrumentType, Transition, Chord, Envelope, Config, OperatorWave } from "./SynthConfig";
import { FilterCoefficients, FrequencyResponse, DynamicBiquadFilter } from "./filtering";
declare global {
    interface Window {
        AudioContext: any;
        webkitAudioContext: any;
    }
}
export declare function clamp(min: number, max: number, val: number): number;
export interface NotePin {
    interval: number;
    time: number;
    size: number;
}
export declare function makeNotePin(interval: number, time: number, size: number): NotePin;
export declare class Note {
    pitches: number[];
    pins: NotePin[];
    start: number;
    end: number;
    continuesLastPattern: boolean;
    constructor(pitch: number, start: number, end: number, size: number, fadeout?: boolean);
    pickMainInterval(): number;
    clone(): Note;
    getEndPinIndex(part: number): number;
}
export declare class Pattern {
    notes: Note[];
    readonly instruments: number[];
    cloneNotes(): Note[];
    reset(): void;
    toJsonObject(song: Song, channel: Channel, isModChannel: boolean): any;
    fromJsonObject(patternObject: any, song: Song, channel: Channel, importedPartsPerBeat: number, isNoiseChannel: boolean, isModChannel: boolean): void;
}
export declare class Operator {
    frequency: number;
    amplitude: number;
    waveform: number;
    pulseWidth: number;
    constructor(index: number);
    reset(index: number): void;
    copy(other: Operator): void;
}
export declare class SpectrumWave {
    spectrum: number[];
    hash: number;
    constructor(isNoiseChannel: boolean);
    reset(isNoiseChannel: boolean): void;
    markCustomWaveDirty(): void;
}
export declare class HarmonicsWave {
    harmonics: number[];
    hash: number;
    constructor();
    reset(): void;
    markCustomWaveDirty(): void;
}
export declare class FilterControlPoint {
    freq: number;
    gain: number;
    type: FilterType;
    set(freqSetting: number, gainSetting: number): void;
    getHz(): number;
    static getHzFromSettingValue(value: number): number;
    static getSettingValueFromHz(hz: number): number;
    static getRoundedSettingValueFromHz(hz: number): number;
    getLinearGain(peakMult?: number): number;
    static getRoundedSettingValueFromLinearGain(linearGain: number): number;
    toCoefficients(filter: FilterCoefficients, sampleRate: number, freqMult?: number, peakMult?: number): void;
    getVolumeCompensationMult(): number;
}
export declare class FilterSettings {
    readonly controlPoints: FilterControlPoint[];
    controlPointCount: number;
    constructor();
    reset(): void;
    addPoint(type: FilterType, freqSetting: number, gainSetting: number): void;
    toJsonObject(): Object;
    fromJsonObject(filterObject: any): void;
    static filtersCanMorph(filterA: FilterSettings, filterB: FilterSettings): boolean;
    static lerpFilters(filterA: FilterSettings, filterB: FilterSettings, pos: number): FilterSettings;
    convertLegacySettings(legacyCutoffSetting: number, legacyResonanceSetting: number, legacyEnv: Envelope): void;
    convertLegacySettingsForSynth(legacyCutoffSetting: number, legacyResonanceSetting: number, allowFirstOrder?: boolean): void;
}
export declare class EnvelopeSettings {
    target: number;
    index: number;
    envelope: number;
    constructor();
    reset(): void;
    toJsonObject(): Object;
    fromJsonObject(envelopeObject: any): void;
}
interface LegacySettings {
    filterCutoff?: number;
    filterResonance?: number;
    filterEnvelope?: Envelope;
    pulseEnvelope?: Envelope;
    operatorEnvelopes?: Envelope[];
    feedbackEnvelope?: Envelope;
}
interface HeldMod {
    volume: number;
    channelIndex: number;
    instrumentIndex: number;
    setting: number;
    holdFor: number;
}
export declare class Instrument {
    type: InstrumentType;
    preset: number;
    chipWave: number;
    chipNoise: number;
    eqFilter: FilterSettings;
    eqFilterType: boolean;
    eqFilterSimpleCut: number;
    eqFilterSimplePeak: number;
    noteFilter: FilterSettings;
    noteFilterType: boolean;
    noteFilterSimpleCut: number;
    noteFilterSimplePeak: number;
    eqSubFilters: (FilterSettings | null)[];
    noteSubFilters: (FilterSettings | null)[];
    tmpEqFilterStart: FilterSettings | null;
    tmpEqFilterEnd: FilterSettings | null;
    tmpNoteFilterStart: FilterSettings | null;
    tmpNoteFilterEnd: FilterSettings | null;
    envelopes: EnvelopeSettings[];
    fadeIn: number;
    fadeOut: number;
    envelopeCount: number;
    transition: number;
    pitchShift: number;
    detune: number;
    vibrato: number;
    interval: number;
    vibratoDepth: number;
    vibratoSpeed: number;
    vibratoDelay: number;
    vibratoType: number;
    envelopeSpeed: number;
    discreteEnvelope: boolean;
    unison: number;
    effects: number;
    chord: number;
    volume: number;
    pan: number;
    panDelay: number;
    arpeggioSpeed: number;
    fastTwoNoteArp: boolean;
    legacyTieOver: boolean;
    clicklessTransition: boolean;
    aliases: boolean;
    pulseWidth: number;
    supersawDynamism: number;
    supersawSpread: number;
    supersawShape: number;
    stringSustain: number;
    stringSustainType: SustainType;
    distortion: number;
    bitcrusherFreq: number;
    bitcrusherQuantization: number;
    chorus: number;
    reverb: number;
    echoSustain: number;
    echoDelay: number;
    algorithm: number;
    feedbackType: number;
    feedbackAmplitude: number;
    customChipWave: Float32Array;
    customChipWaveIntegral: Float32Array;
    readonly operators: Operator[];
    readonly spectrumWave: SpectrumWave;
    readonly harmonicsWave: HarmonicsWave;
    readonly drumsetEnvelopes: number[];
    readonly drumsetSpectrumWaves: SpectrumWave[];
    modChannels: number[];
    modInstruments: number[];
    modulators: number[];
    modFilterTypes: number[];
    invalidModulators: boolean[];
    constructor(isNoiseChannel: boolean, isModChannel: boolean);
    setTypeAndReset(type: InstrumentType, isNoiseChannel: boolean, isModChannel: boolean): void;
    convertLegacySettings(legacySettings: LegacySettings, forceSimpleFilter: boolean): void;
    toJsonObject(): Object;
    fromJsonObject(instrumentObject: any, isNoiseChannel: boolean, isModChannel: boolean, useSlowerRhythm: boolean, useFastTwoNoteArp: boolean, legacyGlobalReverb?: number): void;
    getLargestControlPointCount(forNoteFilter: boolean): number;
    static frequencyFromPitch(pitch: number): number;
    addEnvelope(target: number, index: number, envelope: number): void;
    supportsEnvelopeTarget(target: number, index: number): boolean;
    clearInvalidEnvelopeTargets(): void;
    getTransition(): Transition;
    getFadeInSeconds(): number;
    getFadeOutTicks(): number;
    getChord(): Chord;
    getDrumsetEnvelope(pitch: number): Envelope;
}
export declare class Channel {
    octave: number;
    readonly instruments: Instrument[];
    readonly patterns: Pattern[];
    readonly bars: number[];
    muted: boolean;
    name: string;
}
export declare class Song {
    private static readonly _format;
    private static readonly _oldestBeepboxVersion;
    private static readonly _latestBeepboxVersion;
    private static readonly _oldestJummBoxVersion;
    private static readonly _latestJummBoxVersion;
    private static readonly _variant;
    title: string;
    scale: number;
    key: number;
    tempo: number;
    reverb: number;
    beatsPerBar: number;
    barCount: number;
    patternsPerChannel: number;
    rhythm: number;
    layeredInstruments: boolean;
    patternInstruments: boolean;
    loopStart: number;
    loopLength: number;
    pitchChannelCount: number;
    noiseChannelCount: number;
    modChannelCount: number;
    readonly channels: Channel[];
    limitDecay: number;
    limitRise: number;
    compressionThreshold: number;
    limitThreshold: number;
    compressionRatio: number;
    limitRatio: number;
    masterGain: number;
    inVolumeCap: number;
    outVolumeCap: number;
    constructor(string?: string);
    getNewNoteVolume: (isMod: boolean, modChannel?: number, modInstrument?: number, modCount?: number) => number;
    getVolumeCap: (isMod: boolean, modChannel?: number, modInstrument?: number, modCount?: number) => number;
    getVolumeCapForSetting: (isMod: boolean, modSetting: number, filterType?: number) => number;
    getChannelCount(): number;
    getMaxInstrumentsPerChannel(): number;
    getMaxInstrumentsPerPattern(channelIndex: number): number;
    getMaxInstrumentsPerPatternForChannel(channel: Channel): number;
    getChannelIsNoise(channelIndex: number): boolean;
    getChannelIsMod(channelIndex: number): boolean;
    initToDefault(andResetChannels?: boolean): void;
    toBase64String(): string;
    private static _envelopeFromLegacyIndex;
    fromBase64String(compressed: string): void;
    toJsonObject(enableIntro?: boolean, loopCount?: number, enableOutro?: boolean): Object;
    fromJsonObject(jsonObject: any): void;
    getPattern(channelIndex: number, bar: number): Pattern | null;
    getBeatsPerMinute(): number;
    static getNeededBits(maxValue: number): number;
    restoreLimiterDefaults(): void;
}
export declare class Synth {
    private syncSongState;
    initModFilters(song: Song | null): void;
    warmUpSynthesizer(song: Song | null): void;
    computeLatestModValues(): void;
    determineInvalidModulators(instrument: Instrument): void;
    private static operatorAmplitudeCurve;
    samplesPerSecond: number;
    panningDelayBufferSize: number;
    panningDelayBufferMask: number;
    chorusDelayBufferSize: number;
    chorusDelayBufferMask: number;
    song: Song | null;
    preferLowerLatency: boolean;
    anticipatePoorPerformance: boolean;
    liveInputDuration: number;
    liveBassInputDuration: number;
    liveInputStarted: boolean;
    liveBassInputStarted: boolean;
    liveInputPitches: number[];
    liveBassInputPitches: number[];
    liveInputChannel: number;
    liveBassInputChannel: number;
    liveInputInstruments: number[];
    liveBassInputInstruments: number[];
    loopRepeatCount: number;
    volume: number;
    enableMetronome: boolean;
    countInMetronome: boolean;
    renderingSong: boolean;
    heldMods: HeldMod[];
    private wantToSkip;
    private playheadInternal;
    private bar;
    private prevBar;
    private nextBar;
    private beat;
    private part;
    private tick;
    isAtStartOfTick: boolean;
    isAtEndOfTick: boolean;
    tickSampleCountdown: number;
    private modValues;
    private modInsValues;
    private nextModValues;
    private nextModInsValues;
    private isPlayingSong;
    private isRecording;
    private liveInputEndTime;
    private browserAutomaticallyClearsAudioBuffer;
    static readonly tempFilterStartCoefficients: FilterCoefficients;
    static readonly tempFilterEndCoefficients: FilterCoefficients;
    private tempDrumSetControlPoint;
    tempFrequencyResponse: FrequencyResponse;
    loopBarStart: number;
    loopBarEnd: number;
    private static readonly fmSynthFunctionCache;
    private static readonly effectsFunctionCache;
    private static readonly pickedStringFunctionCache;
    private readonly channels;
    private readonly tonePool;
    private readonly tempMatchedPitchTones;
    private startedMetronome;
    private metronomeSamplesRemaining;
    private metronomeAmplitude;
    private metronomePrevAmplitude;
    private metronomeFilter;
    private limit;
    private tempMonoInstrumentSampleBuffer;
    private audioCtx;
    private scriptNode;
    get playing(): boolean;
    get recording(): boolean;
    get playhead(): number;
    set playhead(value: number);
    getSamplesPerBar(): number;
    getTicksIntoBar(): number;
    getCurrentPart(): number;
    private findPartsInBar;
    getTotalSamples(enableIntro: boolean, enableOutro: boolean, loop: number): number;
    getTotalBars(enableIntro: boolean, enableOutro: boolean, useLoopCount?: number): number;
    constructor(song?: Song | string | null);
    setSong(song: Song | string): void;
    private computeDelayBufferSizes;
    private activateAudio;
    private deactivateAudio;
    maintainLiveInput(): void;
    play(): void;
    pause(): void;
    startRecording(): void;
    resetEffects(): void;
    setModValue(volumeStart: number, volumeEnd: number, channelIndex: number, instrumentIndex: number, setting: number): number;
    getModValue(setting: number, channel?: number | null, instrument?: number | null, nextVal?: boolean): number;
    isAnyModActive(channel: number, instrument: number): boolean;
    unsetMod(setting: number, channel?: number, instrument?: number): void;
    isFilterModActive(forNoteFilter: boolean, channelIdx: number, instrumentIdx: number): boolean;
    isModActive(setting: number, channel?: number, instrument?: number): boolean;
    forceHoldMods(volumeStart: number, channelIndex: number, instrumentIndex: number, setting: number): void;
    snapToStart(): void;
    goToBar(bar: number): void;
    snapToBar(): void;
    jumpIntoLoop(): void;
    goToNextBar(): void;
    goToPrevBar(): void;
    private getNextBar;
    skipBar(): void;
    private audioProcessCallback;
    synthesize(outputDataL: Float32Array, outputDataR: Float32Array, outputBufferLength: number, playSong?: boolean): void;
    private freeTone;
    private newTone;
    private releaseTone;
    private freeReleasedTone;
    freeAllTones(): void;
    private determineLiveInputTones;
    private adjacentPatternHasCompatibleInstrumentTransition;
    static adjacentNotesHaveMatchingPitches(firstNote: Note, secondNote: Note): boolean;
    private moveTonesIntoOrderedTempMatchedList;
    private determineCurrentActiveTones;
    private clearTempMatchedPitchTones;
    private playTone;
    private playModTone;
    private static computeChordExpression;
    private computeTone;
    static getLFOAmplitude(instrument: Instrument, secondsIntoBar: number): number;
    static getInstrumentSynthFunction(instrument: Instrument): Function;
    private static chipSynth;
    private static harmonicsSynth;
    private static pickedStringSynth;
    private static effectsSynth;
    private static pulseWidthSynth;
    private static supersawSynth;
    private static fmSourceTemplate;
    private static operatorSourceTemplate;
    private static noiseSynth;
    private static spectrumSynth;
    private static drumsetSynth;
    private static modSynth;
    private static findRandomZeroCrossing;
    static instrumentVolumeToVolumeMult(instrumentVolume: number): number;
    static volumeMultToInstrumentVolume(volumeMult: number): number;
    static noteSizeToVolumeMult(size: number): number;
    static volumeMultToNoteSize(volumeMult: number): number;
    static fadeInSettingToSeconds(setting: number): number;
    static secondsToFadeInSetting(seconds: number): number;
    static fadeOutSettingToTicks(setting: number): number;
    static ticksToFadeOutSetting(ticks: number): number;
    static detuneToCents(detune: number): number;
    static centsToDetune(cents: number): number;
    static getOperatorWave(waveform: number, pulseWidth: number): OperatorWave;
    private getSamplesPerTick;
    private getSamplesPerTickSpecificBPM;
    static fittingPowerOfTwo(x: number): number;
    private sanitizeFilters;
    static sanitizeDelayLine(delayLine: Float32Array, lastIndex: number, mask: number): void;
    static applyFilters(sample: number, input1: number, input2: number, filterCount: number, filters: DynamicBiquadFilter[]): number;
}
export { Dictionary, DictionaryArray, FilterType, EnvelopeType, InstrumentType, Transition, Chord, Envelope, Config };
